open Types

(** [points_of_throw t] is the number of points scored by throw [t] 
    requires: value of [type throw], and [i] inside [S i], [D i], or [T i]
    must be a positive integer between [1] and [20], or equal to [25] *)
let points_of_throw t = 
  match t with
  | S i -> i
  | D i -> i*2
  | T i -> i*3
;;

(* Assertions (unit tests) *)
let _ = assert (points_of_throw (S 5) = 5);;
let _ = assert (points_of_throw (D 10) = 20);;
let _ =  assert (points_of_throw (T 3) = 9);;
let _ =  assert (points_of_throw (S 1) = 1);;
let _ =  assert (points_of_throw (D 1) = 2);;
let _ =  assert (points_of_throw (T 20) = 60);;


(** [fill_throws pts t] returns a list of throws generated by applying [t] 
    to all integers from [1] to [20], in ascending order. *)
let fill_throws pts t =
  let rec fill_throws_aux lst counter =
    if counter <= min 20 pts then
      fill_throws_aux (t counter :: lst) (counter + 1)
    else lst
  in
  fill_throws_aux [] 1;;

(* Assertions (unit tests) *)
let _ = assert (fill_throws 3 (fun x -> S x) = [S 3; S 2; S 1]);;
let _ = assert (fill_throws 1 (fun x -> D x) = [D 1]);;
let _ =
  let res = fill_throws 170 (fun x -> S x) in
  assert (List.length res = 20);
  assert (List.mem (S 1) res);
  assert (List.mem (S 20) res);
  assert (not (List.mem (S 21) res))

(** [possible_throws points] returns all possible throws that can be done with given [points]
    requires: [points >= 0] *)
let possible_throws points = 
  (fill_throws points (fun x -> S x)) @
  (fill_throws (points/2) (fun x -> D x)) @
  (fill_throws (points/3) (fun x -> T x)) @ 
  (if points >= 50 then [D 25; S 25] else if points >= 25 then [S 25] else []);;

(* Assertions (unit tests) *)
let _ = assert (possible_throws 1 = [S 1]);;
let _ = assert (possible_throws 3 = [S 3; S 2; S 1; D 1; T 1]);;
let _ = assert (possible_throws 0 = []);;

(** [possible_last_throw points] generates all possible double throw to end with
    requires: [points >= 0]*)
let possible_last_throw points = (fill_throws (points/2) (fun x -> D x)) @ (if points >= 50 then [D 25] else []);;

(* Assertions (unit tests) *)
let _ = assert (possible_last_throw 1 = []);;
let _ = assert (possible_last_throw 3 = [D 1]);;
let _ = assert (possible_last_throw 6 = [D 3; D 2; D 1]);;
let _ = assert (possible_last_throw 50 = [D 20; D 19; D 18; D 17; D 16; D 15; D 14; D 13; D 12; D 11; D 10; D 9; 
 D 8; D 7; D 6; D 5; D 4; D 3; D 2; D 1; D 25]);;

(** [compute t_left score checkout] computes all possible checkout combinations 
    to reach a given [score] using at most [t_left] darts, accumulating results 
    in [checkout].
    It recursively explores all valid combinations of dart throws that 
    sum up to the given score. The [checkout] list accumulates throws in reverse 
    order for performance.
    It uses [List.map] for conceptual parallelism (as noted in lectures), 
    which can improve performance when computing large numbers of combinations.
    requires: [t_left >= 0] and [score >= 0]
*)
let rec compute t_left score checkout =
  if score = 0 then [ checkout ]
  else if t_left = 0 then []
  else
    List.concat 
    (List.map (fun x -> compute (t_left - 1) (score - points_of_throw x) (x :: checkout))
     (possible_throws score));;

(* Assertions (unit tests) *)
let _ = assert (compute 1 2 [] = [[S 2]; [D 1]]);;
let _ = assert (compute 0 2 [] = []);;
let _ =
  let result = compute 2 4 [] in
  assert (List.mem [D 2] result);
  assert (List.mem [S 2; S 2] result);
  assert (List.mem [T 1; S 1] result)

(** [compute_checkouts score] returns all valid checkout sequences that sum to [score],
    ending with a valid final throw (double or bullseye).
    It uses [List.map] for conceptual parallelism (as noted in lectures).
    requires: [score >= 0]
*)
let compute_checkouts (score : int) : checkouts =
  List.concat 
  (List.map (fun x -> compute 2 (score - points_of_throw x) [x])
   (possible_last_throw score))
;;

(* Assertions (unit tests) *)
let _ = assert (compute_checkouts 1 = []);;
let _ = assert (compute_checkouts 2 = [[D 1]]);;
let _ = assert (List.mem [D 3] (compute_checkouts 6));; 
let _ = assert (List.mem [D 2; D 1] (compute_checkouts 6));; 
let _ = assert (List.mem [S 2; S 2; D 1] (compute_checkouts 6));; 
let _ = assert (compute_checkouts 0 = []);;