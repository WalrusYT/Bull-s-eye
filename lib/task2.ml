open Types

(** [points_of_throw t] is the number of points scored by throw [t] 
    requires: value of [type throw], and [i] inside [S i], [D i], or [T i]
    must be a positive integer between [1] and [20], or equal to [25] *)
let points_of_throw t = 
  match t with
  | S i -> i
  | D i -> i*2
  | T i -> i*3
;;

(** [fill_throws pts t] returns a list of throws generated by applying [t] 
    to all integers from [1] to [20], in ascending order. *)
let fill_throws pts t =
  let rec fill_throws_aux lst counter =
    if counter <= min 20 pts then
      fill_throws_aux (t counter :: lst) (counter + 1)
    else lst
  in
  fill_throws_aux [] 1;;

(* Assertions (unit tests) *)
let _ = assert (fill_throws 3 (fun x -> S x) = [S 3; S 2; S 1]);;
let _ = assert (fill_throws 1 (fun x -> D x) = [D 1]);;
let _ = assert (fill_throws 170 (fun x -> S x) = [S 20; S 19; S 18; S 17; S 16; S 15; S 14; S 13; S 12; S 11; S 10; S 9; 
  S 8; S 7; S 6; S 5; S 4; S 3; S 2; S 1]);;


(** [possible_throws points] returns all possible throws that can be done with given [points]
    requires: [points >= 0] *)
let possible_throws points = 
  (fill_throws points (fun x -> S x)) @
  (fill_throws (points/2) (fun x -> D x)) @
  (fill_throws (points/3) (fun x -> T x)) @ 
  (if points >= 50 then [D 25; S 25] else if points >= 25 then [S 25] else []);;

(* Assertions (unit tests) *)
let _ = assert (possible_throws 1 = [S 1]);;
let _ = assert (possible_throws 3 = [S 3; S 2; S 1; D 1; T 1]);;
let _ = assert (possible_throws 0 = []);;

(** [possible_last_throw points] generates all possible double throw to end with
    requires: [points >= 0]*)
let possible_last_throw points = (fill_throws (points/2) (fun x -> D x)) @ (if points >= 50 then [D 25] else []);;

(* Assertions (unit tests) *)
let _ = assert (possible_last_throw 1 = []);;
let _ = assert (possible_last_throw 3 = [D 1]);;
let _ = assert (possible_last_throw 6 = [D 3; D 2; D 1]);;
let _ = assert (possible_last_throw 50 = [D 20; D 19; D 18; D 17; D 16; D 15; D 14; D 13; D 12; D 11; D 10; D 9; 
 D 8; D 7; D 6; D 5; D 4; D 3; D 2; D 1; D 25]);;

(** [compute t_left score checkout] computes all possible sequences of throws from
    [checkout] that add up to [score] using at most [t_left] darts.
    The function avoids generating permutations of the same values by maintaining
    traversal order through the [checkout] list.
    requires: [score] >= 0, [t_left] >= 0
*)
let rec compute t_left score checkout =
  if score < 0 then []
  else if score = 0 then [[]]
  else if t_left = 0 then []
  else match checkout with
  | [] -> []
  | h::t -> 
    let with_h = compute (t_left - 1) (score - points_of_throw h) (h::t) in
    let without_h = compute (t_left) (score) t in
    without_h @ List.map (fun x -> h :: x) with_h
;; 

(* Assertions (unit tests) *)
let _ = assert (compute 1 2 [] = []);;
let _ = assert (compute 2 2 [S 1; S 2; S 3; D 1; D 2; T 1] = 
  [[D 1]; [S 2]; [S 1; S 1]]);;
let _ =
  let result = compute 2 4 [S 1; S 2; D 1] in
  assert (List.mem [D 1; D 1] result);
  assert (List.mem [S 2; D 1] result);
  assert (List.mem [S 2; S 2] result)


(** [compute_checkouts score] returns a list of all valid checkout sequences
    that sum up to the given [score], where the last throw must be a valid
    final dart (e.g., a double or bullseye).
    It iterates over all possible final throws using [possible_last_throw],
    and for each one, computes all combinations of up to 2 preceding throws
    (via [compute]) that complete the rest of the score. The final result
    is built by appending the last throw to each of these combinations.
    requires: [score] >= 0
*)
let compute_checkouts (score : int) : checkouts =
  List.concat (
    List.map (fun last_throw ->
      let rest_score = score - points_of_throw last_throw in
      let rest_throws = possible_throws rest_score in
      let previous_combinations = compute 2 rest_score rest_throws in
      List.map (fun x -> x @ [last_throw]) previous_combinations
    ) (possible_last_throw score)
  )